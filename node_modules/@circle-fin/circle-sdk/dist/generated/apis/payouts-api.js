"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayoutsApi = exports.PayoutsApiFactory = exports.PayoutsApiFp = exports.PayoutsApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * PayoutsApi - axios parameter creator
 * @export
 */
const PayoutsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a payout
         * @param {BusinessPayoutCreationRequest} [businessPayoutCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPayout: (businessPayoutCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(businessPayoutCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *  Create a crypto payout.    The following table includes the supported pairs of amount.currency and toAmount.currency for address book payouts:  | amount.currency  | toAmount.currency | | ---------------- | ------------      | | USD              | USD               | | USD              | BTC               | | USD              | ETH               | | USD              | MTC               | | EUR              | EUR               | | BTC              | USD               | | BTC              | BTC               | | ETH              | USD               | | ETH              | ETH               |
         * @summary Create a payout
         * @param {CryptoPayoutCreationRequest} [cryptoPayoutCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayout: (cryptoPayoutCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(cryptoPayoutCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPayout: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("getBusinessPayout", "id", id);
            const localVarPath = `/v1/businessAccount/payouts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("getPayout", "id", id);
            const localVarPath = `/v1/payouts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary List all payouts
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {'wire' | 'cbit'} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Set<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessPayouts: (destination, type, status, from, to, pageBefore, pageAfter, pageSize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (destination !== undefined) {
                localVarQueryParameter["destination"] = destination;
            }
            if (type !== undefined) {
                localVarQueryParameter["type"] = type;
            }
            if (status) {
                localVarQueryParameter["status"] = Array.from(status);
            }
            if (from !== undefined) {
                localVarQueryParameter["from"] =
                    from instanceof Date ? from.toISOString() : from;
            }
            if (to !== undefined) {
                localVarQueryParameter["to"] =
                    to instanceof Date ? to.toISOString() : to;
            }
            if (pageBefore !== undefined) {
                localVarQueryParameter["pageBefore"] = pageBefore;
            }
            if (pageAfter !== undefined) {
                localVarQueryParameter["pageAfter"] = pageAfter;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["pageSize"] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary List all payouts
         * @param {string} [source] Identifier for the source wallet. Filters the fetched payout results to only be from a specific source wallet. If not provided, payouts from all wallets will be returned.
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination. Filters the fetched payout results made to a specific destination. If not provided, payouts to all destinations will be returned.
         * @param {Set<PayoutDestinationType>} [type] Destination type. Filters the results to fetch all payouts made to a specified destination type. This query parameter can be passed multiple times to fetch results matching multiple destination types. The address_book destination type cannot be combined with other types.
         * @param {Set<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {'USD' | 'EUR' | 'BTC' | 'ETH' | 'MTC' | 'FLW' | 'MAN'} [sourceCurrency] Queries items with the specified source currency &#x60;amount.currency&#x60;. Matches any source currency if unspecified.
         * @param {'USD' | 'EUR' | 'BTC' | 'ETH' | 'MTC' | 'FLW' | 'MAN'} [destinationCurrency] Queries items with the specified destination currency &#x60;toAmount.currency&#x60;. Matches any destination currency if unspecified.
         * @param {'ALGO' | 'AVAX' | 'BTC' | 'ETH' | 'FLOW' | 'HBAR' | 'MATIC' | 'SOL' | 'TRX' | 'XLM'} [chain] Queries items with the specified chain. Matches any chain if unspecified
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts: (source, destination, type, status, sourceCurrency, destinationCurrency, chain, from, to, pageBefore, pageAfter, pageSize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (source !== undefined) {
                localVarQueryParameter["source"] = source;
            }
            if (destination !== undefined) {
                localVarQueryParameter["destination"] = destination;
            }
            if (type) {
                localVarQueryParameter["type"] = Array.from(type);
            }
            if (status) {
                localVarQueryParameter["status"] = Array.from(status);
            }
            if (sourceCurrency !== undefined) {
                localVarQueryParameter["sourceCurrency"] = sourceCurrency;
            }
            if (destinationCurrency !== undefined) {
                localVarQueryParameter["destinationCurrency"] = destinationCurrency;
            }
            if (chain !== undefined) {
                localVarQueryParameter["chain"] = chain;
            }
            if (from !== undefined) {
                localVarQueryParameter["from"] =
                    from instanceof Date ? from.toISOString() : from;
            }
            if (to !== undefined) {
                localVarQueryParameter["to"] =
                    to instanceof Date ? to.toISOString() : to;
            }
            if (pageBefore !== undefined) {
                localVarQueryParameter["pageBefore"] = pageBefore;
            }
            if (pageAfter !== undefined) {
                localVarQueryParameter["pageAfter"] = pageAfter;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["pageSize"] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.PayoutsApiAxiosParamCreator = PayoutsApiAxiosParamCreator;
/**
 * PayoutsApi - functional programming interface
 * @export
 */
const PayoutsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PayoutsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a payout
         * @param {BusinessPayoutCreationRequest} [businessPayoutCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPayout(businessPayoutCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBusinessPayout(businessPayoutCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Create a crypto payout.    The following table includes the supported pairs of amount.currency and toAmount.currency for address book payouts:  | amount.currency  | toAmount.currency | | ---------------- | ------------      | | USD              | USD               | | USD              | BTC               | | USD              | ETH               | | USD              | MTC               | | EUR              | EUR               | | BTC              | USD               | | BTC              | BTC               | | ETH              | USD               | | ETH              | ETH               |
         * @summary Create a payout
         * @param {CryptoPayoutCreationRequest} [cryptoPayoutCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayout(cryptoPayoutCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPayout(cryptoPayoutCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPayout(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBusinessPayout(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayout(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List all payouts
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {'wire' | 'cbit'} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Set<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBusinessPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List all payouts
         * @param {string} [source] Identifier for the source wallet. Filters the fetched payout results to only be from a specific source wallet. If not provided, payouts from all wallets will be returned.
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination. Filters the fetched payout results made to a specific destination. If not provided, payouts to all destinations will be returned.
         * @param {Set<PayoutDestinationType>} [type] Destination type. Filters the results to fetch all payouts made to a specified destination type. This query parameter can be passed multiple times to fetch results matching multiple destination types. The address_book destination type cannot be combined with other types.
         * @param {Set<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {'USD' | 'EUR' | 'BTC' | 'ETH' | 'MTC' | 'FLW' | 'MAN'} [sourceCurrency] Queries items with the specified source currency &#x60;amount.currency&#x60;. Matches any source currency if unspecified.
         * @param {'USD' | 'EUR' | 'BTC' | 'ETH' | 'MTC' | 'FLW' | 'MAN'} [destinationCurrency] Queries items with the specified destination currency &#x60;toAmount.currency&#x60;. Matches any destination currency if unspecified.
         * @param {'ALGO' | 'AVAX' | 'BTC' | 'ETH' | 'FLOW' | 'HBAR' | 'MATIC' | 'SOL' | 'TRX' | 'XLM'} [chain] Queries items with the specified chain. Matches any chain if unspecified
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts(source, destination, type, status, sourceCurrency, destinationCurrency, chain, from, to, pageBefore, pageAfter, pageSize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPayouts(source, destination, type, status, sourceCurrency, destinationCurrency, chain, from, to, pageBefore, pageAfter, pageSize, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.PayoutsApiFp = PayoutsApiFp;
/**
 * PayoutsApi - factory interface
 * @export
 */
const PayoutsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PayoutsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a payout
         * @param {BusinessPayoutCreationRequest} [businessPayoutCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPayout(businessPayoutCreationRequest, options) {
            return localVarFp
                .createBusinessPayout(businessPayoutCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Create a crypto payout.    The following table includes the supported pairs of amount.currency and toAmount.currency for address book payouts:  | amount.currency  | toAmount.currency | | ---------------- | ------------      | | USD              | USD               | | USD              | BTC               | | USD              | ETH               | | USD              | MTC               | | EUR              | EUR               | | BTC              | USD               | | BTC              | BTC               | | ETH              | USD               | | ETH              | ETH               |
         * @summary Create a payout
         * @param {CryptoPayoutCreationRequest} [cryptoPayoutCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayout(cryptoPayoutCreationRequest, options) {
            return localVarFp
                .createPayout(cryptoPayoutCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPayout(id, options) {
            return localVarFp
                .getBusinessPayout(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout(id, options) {
            return localVarFp
                .getPayout(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all payouts
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {'wire' | 'cbit'} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Set<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options) {
            return localVarFp
                .listBusinessPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all payouts
         * @param {string} [source] Identifier for the source wallet. Filters the fetched payout results to only be from a specific source wallet. If not provided, payouts from all wallets will be returned.
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination. Filters the fetched payout results made to a specific destination. If not provided, payouts to all destinations will be returned.
         * @param {Set<PayoutDestinationType>} [type] Destination type. Filters the results to fetch all payouts made to a specified destination type. This query parameter can be passed multiple times to fetch results matching multiple destination types. The address_book destination type cannot be combined with other types.
         * @param {Set<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {'USD' | 'EUR' | 'BTC' | 'ETH' | 'MTC' | 'FLW' | 'MAN'} [sourceCurrency] Queries items with the specified source currency &#x60;amount.currency&#x60;. Matches any source currency if unspecified.
         * @param {'USD' | 'EUR' | 'BTC' | 'ETH' | 'MTC' | 'FLW' | 'MAN'} [destinationCurrency] Queries items with the specified destination currency &#x60;toAmount.currency&#x60;. Matches any destination currency if unspecified.
         * @param {'ALGO' | 'AVAX' | 'BTC' | 'ETH' | 'FLOW' | 'HBAR' | 'MATIC' | 'SOL' | 'TRX' | 'XLM'} [chain] Queries items with the specified chain. Matches any chain if unspecified
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts(source, destination, type, status, sourceCurrency, destinationCurrency, chain, from, to, pageBefore, pageAfter, pageSize, options) {
            return localVarFp
                .listPayouts(source, destination, type, status, sourceCurrency, destinationCurrency, chain, from, to, pageBefore, pageAfter, pageSize, options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.PayoutsApiFactory = PayoutsApiFactory;
/**
 * PayoutsApi - object-oriented interface
 * @export
 * @class PayoutsApi
 * @extends {BaseAPI}
 */
class PayoutsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a payout
     * @param {BusinessPayoutCreationRequest} [businessPayoutCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    createBusinessPayout(businessPayoutCreationRequest, options) {
        return (0, exports.PayoutsApiFp)(this.configuration)
            .createBusinessPayout(businessPayoutCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Create a crypto payout.    The following table includes the supported pairs of amount.currency and toAmount.currency for address book payouts:  | amount.currency  | toAmount.currency | | ---------------- | ------------      | | USD              | USD               | | USD              | BTC               | | USD              | ETH               | | USD              | MTC               | | EUR              | EUR               | | BTC              | USD               | | BTC              | BTC               | | ETH              | USD               | | ETH              | ETH               |
     * @summary Create a payout
     * @param {CryptoPayoutCreationRequest} [cryptoPayoutCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    createPayout(cryptoPayoutCreationRequest, options) {
        return (0, exports.PayoutsApiFp)(this.configuration)
            .createPayout(cryptoPayoutCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a payout
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    getBusinessPayout(id, options) {
        return (0, exports.PayoutsApiFp)(this.configuration)
            .getBusinessPayout(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a payout
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    getPayout(id, options) {
        return (0, exports.PayoutsApiFp)(this.configuration)
            .getPayout(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all payouts
     * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
     * @param {'wire' | 'cbit'} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
     * @param {Set<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    listBusinessPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options) {
        return (0, exports.PayoutsApiFp)(this.configuration)
            .listBusinessPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all payouts
     * @param {string} [source] Identifier for the source wallet. Filters the fetched payout results to only be from a specific source wallet. If not provided, payouts from all wallets will be returned.
     * @param {string} [destination] Universally unique identifier (UUID v4) for the destination. Filters the fetched payout results made to a specific destination. If not provided, payouts to all destinations will be returned.
     * @param {Set<PayoutDestinationType>} [type] Destination type. Filters the results to fetch all payouts made to a specified destination type. This query parameter can be passed multiple times to fetch results matching multiple destination types. The address_book destination type cannot be combined with other types.
     * @param {Set<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
     * @param {'USD' | 'EUR' | 'BTC' | 'ETH' | 'MTC' | 'FLW' | 'MAN'} [sourceCurrency] Queries items with the specified source currency &#x60;amount.currency&#x60;. Matches any source currency if unspecified.
     * @param {'USD' | 'EUR' | 'BTC' | 'ETH' | 'MTC' | 'FLW' | 'MAN'} [destinationCurrency] Queries items with the specified destination currency &#x60;toAmount.currency&#x60;. Matches any destination currency if unspecified.
     * @param {'ALGO' | 'AVAX' | 'BTC' | 'ETH' | 'FLOW' | 'HBAR' | 'MATIC' | 'SOL' | 'TRX' | 'XLM'} [chain] Queries items with the specified chain. Matches any chain if unspecified
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    listPayouts(source, destination, type, status, sourceCurrency, destinationCurrency, chain, from, to, pageBefore, pageAfter, pageSize, options) {
        return (0, exports.PayoutsApiFp)(this.configuration)
            .listPayouts(source, destination, type, status, sourceCurrency, destinationCurrency, chain, from, to, pageBefore, pageAfter, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PayoutsApi = PayoutsApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF5b3V0cy1hcGkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZ2VuZXJhdGVkL2FwaXMvcGF5b3V0cy1hcGkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7Ozs7R0FJRzs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsa0RBSWU7QUFFZix5REFBeUQ7QUFDekQsYUFBYTtBQUNiLHNDQVFtQjtBQUNuQixhQUFhO0FBQ2Isa0NBTWlCO0FBMkJqQjs7O0dBR0c7QUFDSSxNQUFNLDJCQUEyQixHQUFHLFVBQ3pDLGFBQTZCO0lBRTdCLE9BQU87UUFDTDs7Ozs7O1dBTUc7UUFDSCxvQkFBb0IsRUFBRSxDQUNwQiw2QkFBNkQsRUFDN0QsVUFBOEIsRUFBRSxFQUNWLEVBQUU7WUFDeEIsTUFBTSxZQUFZLEdBQUcsNkJBQTZCLENBQUM7WUFDbkQsb0ZBQW9GO1lBQ3BGLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksRUFBRSx1QkFBYyxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLENBQUM7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLFdBQVcsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDO2FBQ3pDO1lBRUQsTUFBTSxzQkFBc0IsaUNBQzFCLE1BQU0sRUFBRSxNQUFNLElBQ1gsV0FBVyxHQUNYLE9BQU8sQ0FDWCxDQUFDO1lBQ0YsTUFBTSx1QkFBdUIsR0FBRyxFQUFTLENBQUM7WUFDMUMsTUFBTSxzQkFBc0IsR0FBRyxFQUFTLENBQUM7WUFFekMscUNBQXFDO1lBQ3JDLHNDQUFzQztZQUN0QyxNQUFNLElBQUEsOEJBQXFCLEVBQUMsdUJBQXVCLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFcEUsdUJBQXVCLENBQUMsY0FBYyxDQUFDLEdBQUcsa0JBQWtCLENBQUM7WUFFN0QsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUks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USxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0NBQ0Y7QUF0S0QsZ0NBc0tDIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuXG5pbXBvcnQgZ2xvYmFsQXhpb3MsIHtcbiAgQXhpb3NQcm9taXNlLFxuICBBeGlvc0luc3RhbmNlLFxuICBBeGlvc1JlcXVlc3RDb25maWdcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL2NvbmZpZ3VyYXRpb25cIjtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHtcbiAgRFVNTVlfQkFTRV9VUkwsXG4gIGFzc2VydFBhcmFtRXhpc3RzLFxuICBzZXRCZWFyZXJBdXRoVG9PYmplY3QsXG4gIHNldFNlYXJjaFBhcmFtcyxcbiAgc2VyaWFsaXplRGF0YUlmTmVlZGVkLFxuICB0b1BhdGhTdHJpbmcsXG4gIGNyZWF0ZVJlcXVlc3RGdW5jdGlvblxufSBmcm9tIFwiLi4vY29tbW9uXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge1xuICBCQVNFX1BBVEgsXG4gIENPTExFQ1RJT05fRk9STUFUUyxcbiAgUmVxdWVzdEFyZ3MsXG4gIEJhc2VBUEksXG4gIFJlcXVpcmVkRXJyb3Jcbn0gZnJvbSBcIi4uL2Jhc2VcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEJhZFJlcXVlc3QgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBCdXNpbmVzc1BheW91dENyZWF0aW9uUmVxdWVzdCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IENyZWF0ZUJ1c2luZXNzUGF5b3V0UmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBDcmVhdGVQYXlvdXRSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IENyeXB0b1BheW91dENyZWF0aW9uUmVxdWVzdCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEdldEJ1c2luZXNzUGF5b3V0UmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBHZXRQYXlvdXRSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IExpc3RCdXNpbmVzc1BheW91dHNSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IExpc3RQYXlvdXRzUmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBOb3RBdXRob3JpemVkIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgTm90Rm91bmQgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBQYXlvdXREZXN0aW5hdGlvblR5cGUgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBQYXlvdXRTdGF0dXMgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vKipcbiAqIFBheW91dHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgUGF5b3V0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKFxuICBjb25maWd1cmF0aW9uPzogQ29uZmlndXJhdGlvblxuKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBwYXlvdXRcbiAgICAgKiBAcGFyYW0ge0J1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0fSBbYnVzaW5lc3NQYXlvdXRDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZUJ1c2luZXNzUGF5b3V0OiBhc3luYyAoXG4gICAgICBidXNpbmVzc1BheW91dENyZWF0aW9uUmVxdWVzdD86IEJ1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL2J1c2luZXNzQWNjb3VudC9wYXlvdXRzYDtcbiAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBzZXJpYWxpemVEYXRhSWZOZWVkZWQoXG4gICAgICAgIGJ1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY3J5cHRvIHBheW91dC4gICAgVGhlIGZvbGxvd2luZyB0YWJsZSBpbmNsdWRlcyB0aGUgc3VwcG9ydGVkIHBhaXJzIG9mIGFtb3VudC5jdXJyZW5jeSBhbmQgdG9BbW91bnQuY3VycmVuY3kgZm9yIGFkZHJlc3MgYm9vayBwYXlvdXRzOiAgfCBhbW91bnQuY3VycmVuY3kgIHwgdG9BbW91bnQuY3VycmVuY3kgfCB8IC0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0gICAgICB8IHwgVVNEICAgICAgICAgICAgICB8IFVTRCAgICAgICAgICAgICAgIHwgfCBVU0QgICAgICAgICAgICAgIHwgQlRDICAgICAgICAgICAgICAgfCB8IFVTRCAgICAgICAgICAgICAgfCBFVEggICAgICAgICAgICAgICB8IHwgVVNEICAgICAgICAgICAgICB8IE1UQyAgICAgICAgICAgICAgIHwgfCBFVVIgICAgICAgICAgICAgIHwgRVVSICAgICAgICAgICAgICAgfCB8IEJUQyAgICAgICAgICAgICAgfCBVU0QgICAgICAgICAgICAgICB8IHwgQlRDICAgICAgICAgICAgICB8IEJUQyAgICAgICAgICAgICAgIHwgfCBFVEggICAgICAgICAgICAgIHwgVVNEICAgICAgICAgICAgICAgfCB8IEVUSCAgICAgICAgICAgICAgfCBFVEggICAgICAgICAgICAgICB8XG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgcGF5b3V0XG4gICAgICogQHBhcmFtIHtDcnlwdG9QYXlvdXRDcmVhdGlvblJlcXVlc3R9IFtjcnlwdG9QYXlvdXRDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZVBheW91dDogYXN5bmMgKFxuICAgICAgY3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0PzogQ3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3BheW91dHNgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG4gICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge30gYXMgYW55O1xuXG4gICAgICAvLyBhdXRoZW50aWNhdGlvbiBiZWFyZXJBdXRoIHJlcXVpcmVkXG4gICAgICAvLyBodHRwIGJlYXJlciBhdXRoZW50aWNhdGlvbiByZXF1aXJlZFxuICAgICAgYXdhaXQgc2V0QmVhcmVyQXV0aFRvT2JqZWN0KGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBjb25maWd1cmF0aW9uKTtcblxuICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcblxuICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID1cbiAgICAgICAgYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsXG4gICAgICAgIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9IHNlcmlhbGl6ZURhdGFJZk5lZWRlZChcbiAgICAgICAgY3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHBheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgZ2V0QnVzaW5lc3NQYXlvdXQ6IGFzeW5jIChcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgIGFzc2VydFBhcmFtRXhpc3RzKFwiZ2V0QnVzaW5lc3NQYXlvdXRcIiwgXCJpZFwiLCBpZCk7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL2J1c2luZXNzQWNjb3VudC9wYXlvdXRzL3tpZH1gLnJlcGxhY2UoXG4gICAgICAgIGB7JHtcImlkXCJ9fWAsXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoaWQpKVxuICAgICAgKTtcbiAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG4gICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge30gYXMgYW55O1xuXG4gICAgICAvLyBhdXRoZW50aWNhdGlvbiBiZWFyZXJBdXRoIHJlcXVpcmVkXG4gICAgICAvLyBodHRwIGJlYXJlciBhdXRoZW50aWNhdGlvbiByZXF1aXJlZFxuICAgICAgYXdhaXQgc2V0QmVhcmVyQXV0aFRvT2JqZWN0KGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBjb25maWd1cmF0aW9uKTtcblxuICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID1cbiAgICAgICAgYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsXG4gICAgICAgIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB0b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBwYXlvdXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIG9mIGEgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGdldFBheW91dDogYXN5bmMgKFxuICAgICAgaWQ6IHN0cmluZyxcbiAgICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICAgKTogUHJvbWlzZTxSZXF1ZXN0QXJncz4gPT4ge1xuICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgYXNzZXJ0UGFyYW1FeGlzdHMoXCJnZXRQYXlvdXRcIiwgXCJpZFwiLCBpZCk7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3BheW91dHMve2lkfWAucmVwbGFjZShcbiAgICAgICAgYHske1wiaWRcIn19YCxcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhpZCkpXG4gICAgICApO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHBheW91dHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc3RpbmF0aW9uXSBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgZm9yIHRoZSBkZXN0aW5hdGlvbiBiYW5rIGFjY291bnQuIEZpbHRlcnMgdGhlIHJlc3VsdHMgdG8gZmV0Y2ggYWxsIHBheW91dHMgbWFkZSB0byBhIGRlc3RpbmF0aW9uIGJhbmsgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0geyd3aXJlJyB8ICdjYml0J30gW3R5cGVdIERlc3RpbmF0aW9uIGJhbmsgYWNjb3VudCB0eXBlLiBGaWx0ZXJzIHRoZSByZXN1bHRzIHRvIGZldGNoIGFsbCBwYXlvdXRzIG1hZGUgdG8gYSBzcGVjaWZpZWQgZGVzdGluYXRpb24gYmFuayBhY2NvdW50IHR5cGUuIFRoaXMgcXVlcnkgcGFyYW1ldGVyIGNhbiBiZSBwYXNzZWQgbXVsdGlwbGUgdGltZXMgdG8gZmV0Y2ggcmVzdWx0cyBtYXRjaGluZyBtdWx0aXBsZSBkZXN0aW5hdGlvbiBiYW5rIGFjY291bnQgdHlwZXMuXG4gICAgICogQHBhcmFtIHtTZXQ8UGF5b3V0U3RhdHVzPn0gW3N0YXR1c10gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhdHVzLiBNYXRjaGVzIGFueSBzdGF0dXMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgc2luY2UgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0b10gUXVlcmllcyBpdGVtcyBjcmVhdGVkIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQWZ0ZXJdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBiZWdpbiBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYWZ0ZXIgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUJlZm9yZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBMaW1pdHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXR1cm5lZC4gIFNvbWUgY29sbGVjdGlvbnMgaGF2ZSBhIHN0cmljdCB1cHBlciBib3VuZCB0aGF0IHdpbGwgZGlzcmVnYXJkIHRoaXMgdmFsdWUuIEluIGNhc2UgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgYWxsb3dlZCBsaW1pdCwgdGhlIGNvbGxlY3Rpb24gbGltaXQgd2lsbCBiZSB1c2VkLiAgSWYgYXZvaWRlZCwgdGhlIGNvbGxlY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIHBhZ2Ugc2l6ZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGxpc3RCdXNpbmVzc1BheW91dHM6IGFzeW5jIChcbiAgICAgIGRlc3RpbmF0aW9uPzogc3RyaW5nLFxuICAgICAgdHlwZT86IFwid2lyZVwiIHwgXCJjYml0XCIsXG4gICAgICBzdGF0dXM/OiBTZXQ8UGF5b3V0U3RhdHVzPixcbiAgICAgIGZyb20/OiBzdHJpbmcsXG4gICAgICB0bz86IHN0cmluZyxcbiAgICAgIHBhZ2VCZWZvcmU/OiBzdHJpbmcsXG4gICAgICBwYWdlQWZ0ZXI/OiBzdHJpbmcsXG4gICAgICBwYWdlU2l6ZT86IG51bWJlcixcbiAgICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICAgKTogUHJvbWlzZTxSZXF1ZXN0QXJncz4gPT4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9idXNpbmVzc0FjY291bnQvcGF5b3V0c2A7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGlmIChkZXN0aW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJkZXN0aW5hdGlvblwiXSA9IGRlc3RpbmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJ0eXBlXCJdID0gdHlwZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wic3RhdHVzXCJdID0gQXJyYXkuZnJvbShzdGF0dXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJmcm9tXCJdID1cbiAgICAgICAgICAoZnJvbSBhcyBhbnkpIGluc3RhbmNlb2YgRGF0ZSA/IChmcm9tIGFzIGFueSkudG9JU09TdHJpbmcoKSA6IGZyb207XG4gICAgICB9XG5cbiAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJ0b1wiXSA9XG4gICAgICAgICAgKHRvIGFzIGFueSkgaW5zdGFuY2VvZiBEYXRlID8gKHRvIGFzIGFueSkudG9JU09TdHJpbmcoKSA6IHRvO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZUJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlQmVmb3JlXCJdID0gcGFnZUJlZm9yZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2VBZnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlQWZ0ZXJcIl0gPSBwYWdlQWZ0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlU2l6ZVwiXSA9IHBhZ2VTaXplO1xuICAgICAgfVxuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHBheW91dHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZV0gSWRlbnRpZmllciBmb3IgdGhlIHNvdXJjZSB3YWxsZXQuIEZpbHRlcnMgdGhlIGZldGNoZWQgcGF5b3V0IHJlc3VsdHMgdG8gb25seSBiZSBmcm9tIGEgc3BlY2lmaWMgc291cmNlIHdhbGxldC4gSWYgbm90IHByb3ZpZGVkLCBwYXlvdXRzIGZyb20gYWxsIHdhbGxldHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc3RpbmF0aW9uXSBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgZm9yIHRoZSBkZXN0aW5hdGlvbi4gRmlsdGVycyB0aGUgZmV0Y2hlZCBwYXlvdXQgcmVzdWx0cyBtYWRlIHRvIGEgc3BlY2lmaWMgZGVzdGluYXRpb24uIElmIG5vdCBwcm92aWRlZCwgcGF5b3V0cyB0byBhbGwgZGVzdGluYXRpb25zIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHtTZXQ8UGF5b3V0RGVzdGluYXRpb25UeXBlPn0gW3R5cGVdIERlc3RpbmF0aW9uIHR5cGUuIEZpbHRlcnMgdGhlIHJlc3VsdHMgdG8gZmV0Y2ggYWxsIHBheW91dHMgbWFkZSB0byBhIHNwZWNpZmllZCBkZXN0aW5hdGlvbiB0eXBlLiBUaGlzIHF1ZXJ5IHBhcmFtZXRlciBjYW4gYmUgcGFzc2VkIG11bHRpcGxlIHRpbWVzIHRvIGZldGNoIHJlc3VsdHMgbWF0Y2hpbmcgbXVsdGlwbGUgZGVzdGluYXRpb24gdHlwZXMuIFRoZSBhZGRyZXNzX2Jvb2sgZGVzdGluYXRpb24gdHlwZSBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBvdGhlciB0eXBlcy5cbiAgICAgKiBAcGFyYW0ge1NldDxQYXlvdXRTdGF0dXM+fSBbc3RhdHVzXSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBzdGF0dXMuIE1hdGNoZXMgYW55IHN0YXR1cyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0geydVU0QnIHwgJ0VVUicgfCAnQlRDJyB8ICdFVEgnIHwgJ01UQycgfCAnRkxXJyB8ICdNQU4nfSBbc291cmNlQ3VycmVuY3ldIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIHNvdXJjZSBjdXJyZW5jeSAmI3g2MDthbW91bnQuY3VycmVuY3kmI3g2MDsuIE1hdGNoZXMgYW55IHNvdXJjZSBjdXJyZW5jeSBpZiB1bnNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0geydVU0QnIHwgJ0VVUicgfCAnQlRDJyB8ICdFVEgnIHwgJ01UQycgfCAnRkxXJyB8ICdNQU4nfSBbZGVzdGluYXRpb25DdXJyZW5jeV0gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb24gY3VycmVuY3kgJiN4NjA7dG9BbW91bnQuY3VycmVuY3kmI3g2MDsuIE1hdGNoZXMgYW55IGRlc3RpbmF0aW9uIGN1cnJlbmN5IGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7J0FMR08nIHwgJ0FWQVgnIHwgJ0JUQycgfCAnRVRIJyB8ICdGTE9XJyB8ICdIQkFSJyB8ICdNQVRJQycgfCAnU09MJyB8ICdUUlgnIHwgJ1hMTSd9IFtjaGFpbl0gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgY2hhaW4uIE1hdGNoZXMgYW55IGNoYWluIGlmIHVuc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgc2luY2UgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0b10gUXVlcmllcyBpdGVtcyBjcmVhdGVkIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQWZ0ZXJdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBiZWdpbiBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYWZ0ZXIgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUJlZm9yZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBMaW1pdHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXR1cm5lZC4gIFNvbWUgY29sbGVjdGlvbnMgaGF2ZSBhIHN0cmljdCB1cHBlciBib3VuZCB0aGF0IHdpbGwgZGlzcmVnYXJkIHRoaXMgdmFsdWUuIEluIGNhc2UgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgYWxsb3dlZCBsaW1pdCwgdGhlIGNvbGxlY3Rpb24gbGltaXQgd2lsbCBiZSB1c2VkLiAgSWYgYXZvaWRlZCwgdGhlIGNvbGxlY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIHBhZ2Ugc2l6ZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGxpc3RQYXlvdXRzOiBhc3luYyAoXG4gICAgICBzb3VyY2U/OiBzdHJpbmcsXG4gICAgICBkZXN0aW5hdGlvbj86IHN0cmluZyxcbiAgICAgIHR5cGU/OiBTZXQ8UGF5b3V0RGVzdGluYXRpb25UeXBlPixcbiAgICAgIHN0YXR1cz86IFNldDxQYXlvdXRTdGF0dXM+LFxuICAgICAgc291cmNlQ3VycmVuY3k/OiBcIlVTRFwiIHwgXCJFVVJcIiB8IFwiQlRDXCIgfCBcIkVUSFwiIHwgXCJNVENcIiB8IFwiRkxXXCIgfCBcIk1BTlwiLFxuICAgICAgZGVzdGluYXRpb25DdXJyZW5jeT86XG4gICAgICAgIHwgXCJVU0RcIlxuICAgICAgICB8IFwiRVVSXCJcbiAgICAgICAgfCBcIkJUQ1wiXG4gICAgICAgIHwgXCJFVEhcIlxuICAgICAgICB8IFwiTVRDXCJcbiAgICAgICAgfCBcIkZMV1wiXG4gICAgICAgIHwgXCJNQU5cIixcbiAgICAgIGNoYWluPzpcbiAgICAgICAgfCBcIkFMR09cIlxuICAgICAgICB8IFwiQVZBWFwiXG4gICAgICAgIHwgXCJCVENcIlxuICAgICAgICB8IFwiRVRIXCJcbiAgICAgICAgfCBcIkZMT1dcIlxuICAgICAgICB8IFwiSEJBUlwiXG4gICAgICAgIHwgXCJNQVRJQ1wiXG4gICAgICAgIHwgXCJTT0xcIlxuICAgICAgICB8IFwiVFJYXCJcbiAgICAgICAgfCBcIlhMTVwiLFxuICAgICAgZnJvbT86IHN0cmluZyxcbiAgICAgIHRvPzogc3RyaW5nLFxuICAgICAgcGFnZUJlZm9yZT86IHN0cmluZyxcbiAgICAgIHBhZ2VBZnRlcj86IHN0cmluZyxcbiAgICAgIHBhZ2VTaXplPzogbnVtYmVyLFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3BheW91dHNgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcInNvdXJjZVwiXSA9IHNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlc3RpbmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcImRlc3RpbmF0aW9uXCJdID0gZGVzdGluYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJ0eXBlXCJdID0gQXJyYXkuZnJvbSh0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wic3RhdHVzXCJdID0gQXJyYXkuZnJvbShzdGF0dXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlQ3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wic291cmNlQ3VycmVuY3lcIl0gPSBzb3VyY2VDdXJyZW5jeTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlc3RpbmF0aW9uQ3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wiZGVzdGluYXRpb25DdXJyZW5jeVwiXSA9IGRlc3RpbmF0aW9uQ3VycmVuY3k7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJjaGFpblwiXSA9IGNoYWluO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJmcm9tXCJdID1cbiAgICAgICAgICAoZnJvbSBhcyBhbnkpIGluc3RhbmNlb2YgRGF0ZSA/IChmcm9tIGFzIGFueSkudG9JU09TdHJpbmcoKSA6IGZyb207XG4gICAgICB9XG5cbiAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJ0b1wiXSA9XG4gICAgICAgICAgKHRvIGFzIGFueSkgaW5zdGFuY2VvZiBEYXRlID8gKHRvIGFzIGFueSkudG9JU09TdHJpbmcoKSA6IHRvO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZUJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlQmVmb3JlXCJdID0gcGFnZUJlZm9yZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2VBZnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlQWZ0ZXJcIl0gPSBwYWdlQWZ0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlU2l6ZVwiXSA9IHBhZ2VTaXplO1xuICAgICAgfVxuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQYXlvdXRzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFBheW91dHNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uPzogQ29uZmlndXJhdGlvbikge1xuICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gUGF5b3V0c0FwaUF4aW9zUGFyYW1DcmVhdG9yKGNvbmZpZ3VyYXRpb24pO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgcGF5b3V0XG4gICAgICogQHBhcmFtIHtCdXNpbmVzc1BheW91dENyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCdXNpbmVzc1BheW91dChcbiAgICAgIGJ1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0PzogQnVzaW5lc3NQYXlvdXRDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8Q3JlYXRlQnVzaW5lc3NQYXlvdXRSZXNwb25zZT5cbiAgICA+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID1cbiAgICAgICAgYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVCdXNpbmVzc1BheW91dChcbiAgICAgICAgICBidXNpbmVzc1BheW91dENyZWF0aW9uUmVxdWVzdCxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICBsb2NhbFZhckF4aW9zQXJncyxcbiAgICAgICAgZ2xvYmFsQXhpb3MsXG4gICAgICAgIEJBU0VfUEFUSCxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjcnlwdG8gcGF5b3V0LiAgICBUaGUgZm9sbG93aW5nIHRhYmxlIGluY2x1ZGVzIHRoZSBzdXBwb3J0ZWQgcGFpcnMgb2YgYW1vdW50LmN1cnJlbmN5IGFuZCB0b0Ftb3VudC5jdXJyZW5jeSBmb3IgYWRkcmVzcyBib29rIHBheW91dHM6ICB8IGFtb3VudC5jdXJyZW5jeSAgfCB0b0Ftb3VudC5jdXJyZW5jeSB8IHwgLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLSAgICAgIHwgfCBVU0QgICAgICAgICAgICAgIHwgVVNEICAgICAgICAgICAgICAgfCB8IFVTRCAgICAgICAgICAgICAgfCBCVEMgICAgICAgICAgICAgICB8IHwgVVNEICAgICAgICAgICAgICB8IEVUSCAgICAgICAgICAgICAgIHwgfCBVU0QgICAgICAgICAgICAgIHwgTVRDICAgICAgICAgICAgICAgfCB8IEVVUiAgICAgICAgICAgICAgfCBFVVIgICAgICAgICAgICAgICB8IHwgQlRDICAgICAgICAgICAgICB8IFVTRCAgICAgICAgICAgICAgIHwgfCBCVEMgICAgICAgICAgICAgIHwgQlRDICAgICAgICAgICAgICAgfCB8IEVUSCAgICAgICAgICAgICAgfCBVU0QgICAgICAgICAgICAgICB8IHwgRVRIICAgICAgICAgICAgICB8IEVUSCAgICAgICAgICAgICAgIHxcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBwYXlvdXRcbiAgICAgKiBAcGFyYW0ge0NyeXB0b1BheW91dENyZWF0aW9uUmVxdWVzdH0gW2NyeXB0b1BheW91dENyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUGF5b3V0KFxuICAgICAgY3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0PzogQ3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICAgICk6IFByb21pc2U8XG4gICAgICAoXG4gICAgICAgIGF4aW9zPzogQXhpb3NJbnN0YW5jZSxcbiAgICAgICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICAgICkgPT4gQXhpb3NQcm9taXNlPENyZWF0ZVBheW91dFJlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVBheW91dChcbiAgICAgICAgY3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHBheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnVzaW5lc3NQYXlvdXQoXG4gICAgICBpZDogc3RyaW5nLFxuICAgICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICAgICk6IFByb21pc2U8XG4gICAgICAoXG4gICAgICAgIGF4aW9zPzogQXhpb3NJbnN0YW5jZSxcbiAgICAgICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICAgICkgPT4gQXhpb3NQcm9taXNlPEdldEJ1c2luZXNzUGF5b3V0UmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9XG4gICAgICAgIGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0QnVzaW5lc3NQYXlvdXQoaWQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHBheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGF5b3V0KFxuICAgICAgaWQ6IHN0cmluZyxcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxHZXRQYXlvdXRSZXNwb25zZT5cbiAgICA+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRQYXlvdXQoXG4gICAgICAgIGlkLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHBheW91dHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc3RpbmF0aW9uXSBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgZm9yIHRoZSBkZXN0aW5hdGlvbiBiYW5rIGFjY291bnQuIEZpbHRlcnMgdGhlIHJlc3VsdHMgdG8gZmV0Y2ggYWxsIHBheW91dHMgbWFkZSB0byBhIGRlc3RpbmF0aW9uIGJhbmsgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0geyd3aXJlJyB8ICdjYml0J30gW3R5cGVdIERlc3RpbmF0aW9uIGJhbmsgYWNjb3VudCB0eXBlLiBGaWx0ZXJzIHRoZSByZXN1bHRzIHRvIGZldGNoIGFsbCBwYXlvdXRzIG1hZGUgdG8gYSBzcGVjaWZpZWQgZGVzdGluYXRpb24gYmFuayBhY2NvdW50IHR5cGUuIFRoaXMgcXVlcnkgcGFyYW1ldGVyIGNhbiBiZSBwYXNzZWQgbXVsdGlwbGUgdGltZXMgdG8gZmV0Y2ggcmVzdWx0cyBtYXRjaGluZyBtdWx0aXBsZSBkZXN0aW5hdGlvbiBiYW5rIGFjY291bnQgdHlwZXMuXG4gICAgICogQHBhcmFtIHtTZXQ8UGF5b3V0U3RhdHVzPn0gW3N0YXR1c10gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhdHVzLiBNYXRjaGVzIGFueSBzdGF0dXMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgc2luY2UgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0b10gUXVlcmllcyBpdGVtcyBjcmVhdGVkIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQWZ0ZXJdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBiZWdpbiBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYWZ0ZXIgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUJlZm9yZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBMaW1pdHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXR1cm5lZC4gIFNvbWUgY29sbGVjdGlvbnMgaGF2ZSBhIHN0cmljdCB1cHBlciBib3VuZCB0aGF0IHdpbGwgZGlzcmVnYXJkIHRoaXMgdmFsdWUuIEluIGNhc2UgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgYWxsb3dlZCBsaW1pdCwgdGhlIGNvbGxlY3Rpb24gbGltaXQgd2lsbCBiZSB1c2VkLiAgSWYgYXZvaWRlZCwgdGhlIGNvbGxlY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIHBhZ2Ugc2l6ZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RCdXNpbmVzc1BheW91dHMoXG4gICAgICBkZXN0aW5hdGlvbj86IHN0cmluZyxcbiAgICAgIHR5cGU/OiBcIndpcmVcIiB8IFwiY2JpdFwiLFxuICAgICAgc3RhdHVzPzogU2V0PFBheW91dFN0YXR1cz4sXG4gICAgICBmcm9tPzogc3RyaW5nLFxuICAgICAgdG8/OiBzdHJpbmcsXG4gICAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8TGlzdEJ1c2luZXNzUGF5b3V0c1Jlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPVxuICAgICAgICBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RCdXNpbmVzc1BheW91dHMoXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICBwYWdlQmVmb3JlLFxuICAgICAgICAgIHBhZ2VBZnRlcixcbiAgICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICBsb2NhbFZhckF4aW9zQXJncyxcbiAgICAgICAgZ2xvYmFsQXhpb3MsXG4gICAgICAgIEJBU0VfUEFUSCxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgTGlzdCBhbGwgcGF5b3V0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlXSBJZGVudGlmaWVyIGZvciB0aGUgc291cmNlIHdhbGxldC4gRmlsdGVycyB0aGUgZmV0Y2hlZCBwYXlvdXQgcmVzdWx0cyB0byBvbmx5IGJlIGZyb20gYSBzcGVjaWZpYyBzb3VyY2Ugd2FsbGV0LiBJZiBub3QgcHJvdmlkZWQsIHBheW91dHMgZnJvbSBhbGwgd2FsbGV0cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVzdGluYXRpb25dIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBmb3IgdGhlIGRlc3RpbmF0aW9uLiBGaWx0ZXJzIHRoZSBmZXRjaGVkIHBheW91dCByZXN1bHRzIG1hZGUgdG8gYSBzcGVjaWZpYyBkZXN0aW5hdGlvbi4gSWYgbm90IHByb3ZpZGVkLCBwYXlvdXRzIHRvIGFsbCBkZXN0aW5hdGlvbnMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0ge1NldDxQYXlvdXREZXN0aW5hdGlvblR5cGU+fSBbdHlwZV0gRGVzdGluYXRpb24gdHlwZS4gRmlsdGVycyB0aGUgcmVzdWx0cyB0byBmZXRjaCBhbGwgcGF5b3V0cyBtYWRlIHRvIGEgc3BlY2lmaWVkIGRlc3RpbmF0aW9uIHR5cGUuIFRoaXMgcXVlcnkgcGFyYW1ldGVyIGNhbiBiZSBwYXNzZWQgbXVsdGlwbGUgdGltZXMgdG8gZmV0Y2ggcmVzdWx0cyBtYXRjaGluZyBtdWx0aXBsZSBkZXN0aW5hdGlvbiB0eXBlcy4gVGhlIGFkZHJlc3NfYm9vayBkZXN0aW5hdGlvbiB0eXBlIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIHR5cGVzLlxuICAgICAqIEBwYXJhbSB7U2V0PFBheW91dFN0YXR1cz59IFtzdGF0dXNdIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXR1cy4gTWF0Y2hlcyBhbnkgc3RhdHVzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7J1VTRCcgfCAnRVVSJyB8ICdCVEMnIHwgJ0VUSCcgfCAnTVRDJyB8ICdGTFcnIHwgJ01BTid9IFtzb3VyY2VDdXJyZW5jeV0gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc291cmNlIGN1cnJlbmN5ICYjeDYwO2Ftb3VudC5jdXJyZW5jeSYjeDYwOy4gTWF0Y2hlcyBhbnkgc291cmNlIGN1cnJlbmN5IGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7J1VTRCcgfCAnRVVSJyB8ICdCVEMnIHwgJ0VUSCcgfCAnTVRDJyB8ICdGTFcnIHwgJ01BTid9IFtkZXN0aW5hdGlvbkN1cnJlbmN5XSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvbiBjdXJyZW5jeSAmI3g2MDt0b0Ftb3VudC5jdXJyZW5jeSYjeDYwOy4gTWF0Y2hlcyBhbnkgZGVzdGluYXRpb24gY3VycmVuY3kgaWYgdW5zcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHsnQUxHTycgfCAnQVZBWCcgfCAnQlRDJyB8ICdFVEgnIHwgJ0ZMT1cnIHwgJ0hCQVInIHwgJ01BVElDJyB8ICdTT0wnIHwgJ1RSWCcgfCAnWExNJ30gW2NoYWluXSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBjaGFpbi4gTWF0Y2hlcyBhbnkgY2hhaW4gaWYgdW5zcGVjaWZpZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zyb21dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUJlZm9yZV0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGVuZCBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYmVmb3JlIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VBZnRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VBZnRlcl0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGJlZ2luIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBhZnRlciB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQmVmb3JlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdFBheW91dHMoXG4gICAgICBzb3VyY2U/OiBzdHJpbmcsXG4gICAgICBkZXN0aW5hdGlvbj86IHN0cmluZyxcbiAgICAgIHR5cGU/OiBTZXQ8UGF5b3V0RGVzdGluYXRpb25UeXBlPixcbiAgICAgIHN0YXR1cz86IFNldDxQYXlvdXRTdGF0dXM+LFxuICAgICAgc291cmNlQ3VycmVuY3k/OiBcIlVTRFwiIHwgXCJFVVJcIiB8IFwiQlRDXCIgfCBcIkVUSFwiIHwgXCJNVENcIiB8IFwiRkxXXCIgfCBcIk1BTlwiLFxuICAgICAgZGVzdGluYXRpb25DdXJyZW5jeT86XG4gICAgICAgIHwgXCJVU0RcIlxuICAgICAgICB8IFwiRVVSXCJcbiAgICAgICAgfCBcIkJUQ1wiXG4gICAgICAgIHwgXCJFVEhcIlxuICAgICAgICB8IFwiTVRDXCJcbiAgICAgICAgfCBcIkZMV1wiXG4gICAgICAgIHwgXCJNQU5cIixcbiAgICAgIGNoYWluPzpcbiAgICAgICAgfCBcIkFMR09cIlxuICAgICAgICB8IFwiQVZBWFwiXG4gICAgICAgIHwgXCJCVENcIlxuICAgICAgICB8IFwiRVRIXCJcbiAgICAgICAgfCBcIkZMT1dcIlxuICAgICAgICB8IFwiSEJBUlwiXG4gICAgICAgIHwgXCJNQVRJQ1wiXG4gICAgICAgIHwgXCJTT0xcIlxuICAgICAgICB8IFwiVFJYXCJcbiAgICAgICAgfCBcIlhMTVwiLFxuICAgICAgZnJvbT86IHN0cmluZyxcbiAgICAgIHRvPzogc3RyaW5nLFxuICAgICAgcGFnZUJlZm9yZT86IHN0cmluZyxcbiAgICAgIHBhZ2VBZnRlcj86IHN0cmluZyxcbiAgICAgIHBhZ2VTaXplPzogbnVtYmVyLFxuICAgICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICAgICk6IFByb21pc2U8XG4gICAgICAoXG4gICAgICAgIGF4aW9zPzogQXhpb3NJbnN0YW5jZSxcbiAgICAgICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICAgICkgPT4gQXhpb3NQcm9taXNlPExpc3RQYXlvdXRzUmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFBheW91dHMoXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgc291cmNlQ3VycmVuY3ksXG4gICAgICAgIGRlc3RpbmF0aW9uQ3VycmVuY3ksXG4gICAgICAgIGNoYWluLFxuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgcGFnZUJlZm9yZSxcbiAgICAgICAgcGFnZUFmdGVyLFxuICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogUGF5b3V0c0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBQYXlvdXRzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChcbiAgY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb24sXG4gIGJhc2VQYXRoPzogc3RyaW5nLFxuICBheGlvcz86IEF4aW9zSW5zdGFuY2Vcbikge1xuICBjb25zdCBsb2NhbFZhckZwID0gUGF5b3V0c0FwaUZwKGNvbmZpZ3VyYXRpb24pO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgcGF5b3V0XG4gICAgICogQHBhcmFtIHtCdXNpbmVzc1BheW91dENyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBjcmVhdGVCdXNpbmVzc1BheW91dChcbiAgICAgIGJ1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0PzogQnVzaW5lc3NQYXlvdXRDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPENyZWF0ZUJ1c2luZXNzUGF5b3V0UmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5jcmVhdGVCdXNpbmVzc1BheW91dChidXNpbmVzc1BheW91dENyZWF0aW9uUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY3J5cHRvIHBheW91dC4gICAgVGhlIGZvbGxvd2luZyB0YWJsZSBpbmNsdWRlcyB0aGUgc3VwcG9ydGVkIHBhaXJzIG9mIGFtb3VudC5jdXJyZW5jeSBhbmQgdG9BbW91bnQuY3VycmVuY3kgZm9yIGFkZHJlc3MgYm9vayBwYXlvdXRzOiAgfCBhbW91bnQuY3VycmVuY3kgIHwgdG9BbW91bnQuY3VycmVuY3kgfCB8IC0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0gICAgICB8IHwgVVNEICAgICAgICAgICAgICB8IFVTRCAgICAgICAgICAgICAgIHwgfCBVU0QgICAgICAgICAgICAgIHwgQlRDICAgICAgICAgICAgICAgfCB8IFVTRCAgICAgICAgICAgICAgfCBFVEggICAgICAgICAgICAgICB8IHwgVVNEICAgICAgICAgICAgICB8IE1UQyAgICAgICAgICAgICAgIHwgfCBFVVIgICAgICAgICAgICAgIHwgRVVSICAgICAgICAgICAgICAgfCB8IEJUQyAgICAgICAgICAgICAgfCBVU0QgICAgICAgICAgICAgICB8IHwgQlRDICAgICAgICAgICAgICB8IEJUQyAgICAgICAgICAgICAgIHwgfCBFVEggICAgICAgICAgICAgIHwgVVNEICAgICAgICAgICAgICAgfCB8IEVUSCAgICAgICAgICAgICAgfCBFVEggICAgICAgICAgICAgICB8XG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgcGF5b3V0XG4gICAgICogQHBhcmFtIHtDcnlwdG9QYXlvdXRDcmVhdGlvblJlcXVlc3R9IFtjcnlwdG9QYXlvdXRDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZVBheW91dChcbiAgICAgIGNyeXB0b1BheW91dENyZWF0aW9uUmVxdWVzdD86IENyeXB0b1BheW91dENyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBhbnlcbiAgICApOiBBeGlvc1Byb21pc2U8Q3JlYXRlUGF5b3V0UmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5jcmVhdGVQYXlvdXQoY3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgcGF5b3V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRCdXNpbmVzc1BheW91dChcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPEdldEJ1c2luZXNzUGF5b3V0UmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5nZXRCdXNpbmVzc1BheW91dChpZCwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHBheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgZ2V0UGF5b3V0KGlkOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiBBeGlvc1Byb21pc2U8R2V0UGF5b3V0UmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5nZXRQYXlvdXQoaWQsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFsbCBwYXlvdXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXN0aW5hdGlvbl0gVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIGZvciB0aGUgZGVzdGluYXRpb24gYmFuayBhY2NvdW50LiBGaWx0ZXJzIHRoZSByZXN1bHRzIHRvIGZldGNoIGFsbCBwYXlvdXRzIG1hZGUgdG8gYSBkZXN0aW5hdGlvbiBiYW5rIGFjY291bnQuXG4gICAgICogQHBhcmFtIHsnd2lyZScgfCAnY2JpdCd9IFt0eXBlXSBEZXN0aW5hdGlvbiBiYW5rIGFjY291bnQgdHlwZS4gRmlsdGVycyB0aGUgcmVzdWx0cyB0byBmZXRjaCBhbGwgcGF5b3V0cyBtYWRlIHRvIGEgc3BlY2lmaWVkIGRlc3RpbmF0aW9uIGJhbmsgYWNjb3VudCB0eXBlLiBUaGlzIHF1ZXJ5IHBhcmFtZXRlciBjYW4gYmUgcGFzc2VkIG11bHRpcGxlIHRpbWVzIHRvIGZldGNoIHJlc3VsdHMgbWF0Y2hpbmcgbXVsdGlwbGUgZGVzdGluYXRpb24gYmFuayBhY2NvdW50IHR5cGVzLlxuICAgICAqIEBwYXJhbSB7U2V0PFBheW91dFN0YXR1cz59IFtzdGF0dXNdIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXR1cy4gTWF0Y2hlcyBhbnkgc3RhdHVzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdG9dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBiZWZvcmUgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmV0dXJuZWQuICBTb21lIGNvbGxlY3Rpb25zIGhhdmUgYSBzdHJpY3QgdXBwZXIgYm91bmQgdGhhdCB3aWxsIGRpc3JlZ2FyZCB0aGlzIHZhbHVlLiBJbiBjYXNlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgaGlnaGVyIHRoYW4gdGhlIGFsbG93ZWQgbGltaXQsIHRoZSBjb2xsZWN0aW9uIGxpbWl0IHdpbGwgYmUgdXNlZC4gIElmIGF2b2lkZWQsIHRoZSBjb2xsZWN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZSBwYWdlIHNpemUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBsaXN0QnVzaW5lc3NQYXlvdXRzKFxuICAgICAgZGVzdGluYXRpb24/OiBzdHJpbmcsXG4gICAgICB0eXBlPzogXCJ3aXJlXCIgfCBcImNiaXRcIixcbiAgICAgIHN0YXR1cz86IFNldDxQYXlvdXRTdGF0dXM+LFxuICAgICAgZnJvbT86IHN0cmluZyxcbiAgICAgIHRvPzogc3RyaW5nLFxuICAgICAgcGFnZUJlZm9yZT86IHN0cmluZyxcbiAgICAgIHBhZ2VBZnRlcj86IHN0cmluZyxcbiAgICAgIHBhZ2VTaXplPzogbnVtYmVyLFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTxMaXN0QnVzaW5lc3NQYXlvdXRzUmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5saXN0QnVzaW5lc3NQYXlvdXRzKFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgcGFnZUJlZm9yZSxcbiAgICAgICAgICBwYWdlQWZ0ZXIsXG4gICAgICAgICAgcGFnZVNpemUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFsbCBwYXlvdXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VdIElkZW50aWZpZXIgZm9yIHRoZSBzb3VyY2Ugd2FsbGV0LiBGaWx0ZXJzIHRoZSBmZXRjaGVkIHBheW91dCByZXN1bHRzIHRvIG9ubHkgYmUgZnJvbSBhIHNwZWNpZmljIHNvdXJjZSB3YWxsZXQuIElmIG5vdCBwcm92aWRlZCwgcGF5b3V0cyBmcm9tIGFsbCB3YWxsZXRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXN0aW5hdGlvbl0gVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIGZvciB0aGUgZGVzdGluYXRpb24uIEZpbHRlcnMgdGhlIGZldGNoZWQgcGF5b3V0IHJlc3VsdHMgbWFkZSB0byBhIHNwZWNpZmljIGRlc3RpbmF0aW9uLiBJZiBub3QgcHJvdmlkZWQsIHBheW91dHMgdG8gYWxsIGRlc3RpbmF0aW9ucyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7U2V0PFBheW91dERlc3RpbmF0aW9uVHlwZT59IFt0eXBlXSBEZXN0aW5hdGlvbiB0eXBlLiBGaWx0ZXJzIHRoZSByZXN1bHRzIHRvIGZldGNoIGFsbCBwYXlvdXRzIG1hZGUgdG8gYSBzcGVjaWZpZWQgZGVzdGluYXRpb24gdHlwZS4gVGhpcyBxdWVyeSBwYXJhbWV0ZXIgY2FuIGJlIHBhc3NlZCBtdWx0aXBsZSB0aW1lcyB0byBmZXRjaCByZXN1bHRzIG1hdGNoaW5nIG11bHRpcGxlIGRlc3RpbmF0aW9uIHR5cGVzLiBUaGUgYWRkcmVzc19ib29rIGRlc3RpbmF0aW9uIHR5cGUgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgdHlwZXMuXG4gICAgICogQHBhcmFtIHtTZXQ8UGF5b3V0U3RhdHVzPn0gW3N0YXR1c10gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhdHVzLiBNYXRjaGVzIGFueSBzdGF0dXMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHsnVVNEJyB8ICdFVVInIHwgJ0JUQycgfCAnRVRIJyB8ICdNVEMnIHwgJ0ZMVycgfCAnTUFOJ30gW3NvdXJjZUN1cnJlbmN5XSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBzb3VyY2UgY3VycmVuY3kgJiN4NjA7YW1vdW50LmN1cnJlbmN5JiN4NjA7LiBNYXRjaGVzIGFueSBzb3VyY2UgY3VycmVuY3kgaWYgdW5zcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHsnVVNEJyB8ICdFVVInIHwgJ0JUQycgfCAnRVRIJyB8ICdNVEMnIHwgJ0ZMVycgfCAnTUFOJ30gW2Rlc3RpbmF0aW9uQ3VycmVuY3ldIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIGRlc3RpbmF0aW9uIGN1cnJlbmN5ICYjeDYwO3RvQW1vdW50LmN1cnJlbmN5JiN4NjA7LiBNYXRjaGVzIGFueSBkZXN0aW5hdGlvbiBjdXJyZW5jeSBpZiB1bnNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0geydBTEdPJyB8ICdBVkFYJyB8ICdCVEMnIHwgJ0VUSCcgfCAnRkxPVycgfCAnSEJBUicgfCAnTUFUSUMnIHwgJ1NPTCcgfCAnVFJYJyB8ICdYTE0nfSBbY2hhaW5dIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIGNoYWluLiBNYXRjaGVzIGFueSBjaGFpbiBpZiB1bnNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdG9dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBiZWZvcmUgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmV0dXJuZWQuICBTb21lIGNvbGxlY3Rpb25zIGhhdmUgYSBzdHJpY3QgdXBwZXIgYm91bmQgdGhhdCB3aWxsIGRpc3JlZ2FyZCB0aGlzIHZhbHVlLiBJbiBjYXNlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgaGlnaGVyIHRoYW4gdGhlIGFsbG93ZWQgbGltaXQsIHRoZSBjb2xsZWN0aW9uIGxpbWl0IHdpbGwgYmUgdXNlZC4gIElmIGF2b2lkZWQsIHRoZSBjb2xsZWN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZSBwYWdlIHNpemUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBsaXN0UGF5b3V0cyhcbiAgICAgIHNvdXJjZT86IHN0cmluZyxcbiAgICAgIGRlc3RpbmF0aW9uPzogc3RyaW5nLFxuICAgICAgdHlwZT86IFNldDxQYXlvdXREZXN0aW5hdGlvblR5cGU+LFxuICAgICAgc3RhdHVzPzogU2V0PFBheW91dFN0YXR1cz4sXG4gICAgICBzb3VyY2VDdXJyZW5jeT86IFwiVVNEXCIgfCBcIkVVUlwiIHwgXCJCVENcIiB8IFwiRVRIXCIgfCBcIk1UQ1wiIHwgXCJGTFdcIiB8IFwiTUFOXCIsXG4gICAgICBkZXN0aW5hdGlvbkN1cnJlbmN5PzpcbiAgICAgICAgfCBcIlVTRFwiXG4gICAgICAgIHwgXCJFVVJcIlxuICAgICAgICB8IFwiQlRDXCJcbiAgICAgICAgfCBcIkVUSFwiXG4gICAgICAgIHwgXCJNVENcIlxuICAgICAgICB8IFwiRkxXXCJcbiAgICAgICAgfCBcIk1BTlwiLFxuICAgICAgY2hhaW4/OlxuICAgICAgICB8IFwiQUxHT1wiXG4gICAgICAgIHwgXCJBVkFYXCJcbiAgICAgICAgfCBcIkJUQ1wiXG4gICAgICAgIHwgXCJFVEhcIlxuICAgICAgICB8IFwiRkxPV1wiXG4gICAgICAgIHwgXCJIQkFSXCJcbiAgICAgICAgfCBcIk1BVElDXCJcbiAgICAgICAgfCBcIlNPTFwiXG4gICAgICAgIHwgXCJUUlhcIlxuICAgICAgICB8IFwiWExNXCIsXG4gICAgICBmcm9tPzogc3RyaW5nLFxuICAgICAgdG8/OiBzdHJpbmcsXG4gICAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPExpc3RQYXlvdXRzUmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5saXN0UGF5b3V0cyhcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgc291cmNlQ3VycmVuY3ksXG4gICAgICAgICAgZGVzdGluYXRpb25DdXJyZW5jeSxcbiAgICAgICAgICBjaGFpbixcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHBhZ2VCZWZvcmUsXG4gICAgICAgICAgcGFnZUFmdGVyLFxuICAgICAgICAgIHBhZ2VTaXplLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFBheW91dHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUGF5b3V0c0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmV4cG9ydCBjbGFzcyBQYXlvdXRzQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gIC8qKlxuICAgKlxuICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBwYXlvdXRcbiAgICogQHBhcmFtIHtCdXNpbmVzc1BheW91dENyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0XVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgUGF5b3V0c0FwaVxuICAgKi9cbiAgcHVibGljIGNyZWF0ZUJ1c2luZXNzUGF5b3V0KFxuICAgIGJ1c2luZXNzUGF5b3V0Q3JlYXRpb25SZXF1ZXN0PzogQnVzaW5lc3NQYXlvdXRDcmVhdGlvblJlcXVlc3QsXG4gICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICApIHtcbiAgICByZXR1cm4gUGF5b3V0c0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5jcmVhdGVCdXNpbmVzc1BheW91dChidXNpbmVzc1BheW91dENyZWF0aW9uUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgQ3JlYXRlIGEgY3J5cHRvIHBheW91dC4gICAgVGhlIGZvbGxvd2luZyB0YWJsZSBpbmNsdWRlcyB0aGUgc3VwcG9ydGVkIHBhaXJzIG9mIGFtb3VudC5jdXJyZW5jeSBhbmQgdG9BbW91bnQuY3VycmVuY3kgZm9yIGFkZHJlc3MgYm9vayBwYXlvdXRzOiAgfCBhbW91bnQuY3VycmVuY3kgIHwgdG9BbW91bnQuY3VycmVuY3kgfCB8IC0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0gICAgICB8IHwgVVNEICAgICAgICAgICAgICB8IFVTRCAgICAgICAgICAgICAgIHwgfCBVU0QgICAgICAgICAgICAgIHwgQlRDICAgICAgICAgICAgICAgfCB8IFVTRCAgICAgICAgICAgICAgfCBFVEggICAgICAgICAgICAgICB8IHwgVVNEICAgICAgICAgICAgICB8IE1UQyAgICAgICAgICAgICAgIHwgfCBFVVIgICAgICAgICAgICAgIHwgRVVSICAgICAgICAgICAgICAgfCB8IEJUQyAgICAgICAgICAgICAgfCBVU0QgICAgICAgICAgICAgICB8IHwgQlRDICAgICAgICAgICAgICB8IEJUQyAgICAgICAgICAgICAgIHwgfCBFVEggICAgICAgICAgICAgIHwgVVNEICAgICAgICAgICAgICAgfCB8IEVUSCAgICAgICAgICAgICAgfCBFVEggICAgICAgICAgICAgICB8XG4gICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHBheW91dFxuICAgKiBAcGFyYW0ge0NyeXB0b1BheW91dENyZWF0aW9uUmVxdWVzdH0gW2NyeXB0b1BheW91dENyZWF0aW9uUmVxdWVzdF1cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIFBheW91dHNBcGlcbiAgICovXG4gIHB1YmxpYyBjcmVhdGVQYXlvdXQoXG4gICAgY3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0PzogQ3J5cHRvUGF5b3V0Q3JlYXRpb25SZXF1ZXN0LFxuICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgKSB7XG4gICAgcmV0dXJuIFBheW91dHNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAuY3JlYXRlUGF5b3V0KGNyeXB0b1BheW91dENyZWF0aW9uUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAc3VtbWFyeSBHZXQgYSBwYXlvdXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgUGF5b3V0c0FwaVxuICAgKi9cbiAgcHVibGljIGdldEJ1c2luZXNzUGF5b3V0KGlkOiBzdHJpbmcsIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWcpIHtcbiAgICByZXR1cm4gUGF5b3V0c0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5nZXRCdXNpbmVzc1BheW91dChpZCwgb3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAc3VtbWFyeSBHZXQgYSBwYXlvdXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgUGF5b3V0c0FwaVxuICAgKi9cbiAgcHVibGljIGdldFBheW91dChpZDogc3RyaW5nLCBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnKSB7XG4gICAgcmV0dXJuIFBheW91dHNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAuZ2V0UGF5b3V0KGlkLCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBzdW1tYXJ5IExpc3QgYWxsIHBheW91dHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXN0aW5hdGlvbl0gVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIGZvciB0aGUgZGVzdGluYXRpb24gYmFuayBhY2NvdW50LiBGaWx0ZXJzIHRoZSByZXN1bHRzIHRvIGZldGNoIGFsbCBwYXlvdXRzIG1hZGUgdG8gYSBkZXN0aW5hdGlvbiBiYW5rIGFjY291bnQuXG4gICAqIEBwYXJhbSB7J3dpcmUnIHwgJ2NiaXQnfSBbdHlwZV0gRGVzdGluYXRpb24gYmFuayBhY2NvdW50IHR5cGUuIEZpbHRlcnMgdGhlIHJlc3VsdHMgdG8gZmV0Y2ggYWxsIHBheW91dHMgbWFkZSB0byBhIHNwZWNpZmllZCBkZXN0aW5hdGlvbiBiYW5rIGFjY291bnQgdHlwZS4gVGhpcyBxdWVyeSBwYXJhbWV0ZXIgY2FuIGJlIHBhc3NlZCBtdWx0aXBsZSB0aW1lcyB0byBmZXRjaCByZXN1bHRzIG1hdGNoaW5nIG11bHRpcGxlIGRlc3RpbmF0aW9uIGJhbmsgYWNjb3VudCB0eXBlcy5cbiAgICogQHBhcmFtIHtTZXQ8UGF5b3V0U3RhdHVzPn0gW3N0YXR1c10gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhdHVzLiBNYXRjaGVzIGFueSBzdGF0dXMgaWYgdW5zcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIFBheW91dHNBcGlcbiAgICovXG4gIHB1YmxpYyBsaXN0QnVzaW5lc3NQYXlvdXRzKFxuICAgIGRlc3RpbmF0aW9uPzogc3RyaW5nLFxuICAgIHR5cGU/OiBcIndpcmVcIiB8IFwiY2JpdFwiLFxuICAgIHN0YXR1cz86IFNldDxQYXlvdXRTdGF0dXM+LFxuICAgIGZyb20/OiBzdHJpbmcsXG4gICAgdG8/OiBzdHJpbmcsXG4gICAgcGFnZUJlZm9yZT86IHN0cmluZyxcbiAgICBwYWdlQWZ0ZXI/OiBzdHJpbmcsXG4gICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICApIHtcbiAgICByZXR1cm4gUGF5b3V0c0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5saXN0QnVzaW5lc3NQYXlvdXRzKFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgcGFnZUJlZm9yZSxcbiAgICAgICAgcGFnZUFmdGVyLFxuICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBzdW1tYXJ5IExpc3QgYWxsIHBheW91dHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VdIElkZW50aWZpZXIgZm9yIHRoZSBzb3VyY2Ugd2FsbGV0LiBGaWx0ZXJzIHRoZSBmZXRjaGVkIHBheW91dCByZXN1bHRzIHRvIG9ubHkgYmUgZnJvbSBhIHNwZWNpZmljIHNvdXJjZSB3YWxsZXQuIElmIG5vdCBwcm92aWRlZCwgcGF5b3V0cyBmcm9tIGFsbCB3YWxsZXRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVzdGluYXRpb25dIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBmb3IgdGhlIGRlc3RpbmF0aW9uLiBGaWx0ZXJzIHRoZSBmZXRjaGVkIHBheW91dCByZXN1bHRzIG1hZGUgdG8gYSBzcGVjaWZpYyBkZXN0aW5hdGlvbi4gSWYgbm90IHByb3ZpZGVkLCBwYXlvdXRzIHRvIGFsbCBkZXN0aW5hdGlvbnMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtTZXQ8UGF5b3V0RGVzdGluYXRpb25UeXBlPn0gW3R5cGVdIERlc3RpbmF0aW9uIHR5cGUuIEZpbHRlcnMgdGhlIHJlc3VsdHMgdG8gZmV0Y2ggYWxsIHBheW91dHMgbWFkZSB0byBhIHNwZWNpZmllZCBkZXN0aW5hdGlvbiB0eXBlLiBUaGlzIHF1ZXJ5IHBhcmFtZXRlciBjYW4gYmUgcGFzc2VkIG11bHRpcGxlIHRpbWVzIHRvIGZldGNoIHJlc3VsdHMgbWF0Y2hpbmcgbXVsdGlwbGUgZGVzdGluYXRpb24gdHlwZXMuIFRoZSBhZGRyZXNzX2Jvb2sgZGVzdGluYXRpb24gdHlwZSBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBvdGhlciB0eXBlcy5cbiAgICogQHBhcmFtIHtTZXQ8UGF5b3V0U3RhdHVzPn0gW3N0YXR1c10gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhdHVzLiBNYXRjaGVzIGFueSBzdGF0dXMgaWYgdW5zcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7J1VTRCcgfCAnRVVSJyB8ICdCVEMnIHwgJ0VUSCcgfCAnTVRDJyB8ICdGTFcnIHwgJ01BTid9IFtzb3VyY2VDdXJyZW5jeV0gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc291cmNlIGN1cnJlbmN5ICYjeDYwO2Ftb3VudC5jdXJyZW5jeSYjeDYwOy4gTWF0Y2hlcyBhbnkgc291cmNlIGN1cnJlbmN5IGlmIHVuc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0geydVU0QnIHwgJ0VVUicgfCAnQlRDJyB8ICdFVEgnIHwgJ01UQycgfCAnRkxXJyB8ICdNQU4nfSBbZGVzdGluYXRpb25DdXJyZW5jeV0gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb24gY3VycmVuY3kgJiN4NjA7dG9BbW91bnQuY3VycmVuY3kmI3g2MDsuIE1hdGNoZXMgYW55IGRlc3RpbmF0aW9uIGN1cnJlbmN5IGlmIHVuc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0geydBTEdPJyB8ICdBVkFYJyB8ICdCVEMnIHwgJ0VUSCcgfCAnRkxPVycgfCAnSEJBUicgfCAnTUFUSUMnIHwgJ1NPTCcgfCAnVFJYJyB8ICdYTE0nfSBbY2hhaW5dIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIGNoYWluLiBNYXRjaGVzIGFueSBjaGFpbiBpZiB1bnNwZWNpZmllZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zyb21dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0b10gUXVlcmllcyBpdGVtcyBjcmVhdGVkIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VBZnRlcl0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGJlZ2luIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBhZnRlciB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQmVmb3JlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBMaW1pdHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXR1cm5lZC4gIFNvbWUgY29sbGVjdGlvbnMgaGF2ZSBhIHN0cmljdCB1cHBlciBib3VuZCB0aGF0IHdpbGwgZGlzcmVnYXJkIHRoaXMgdmFsdWUuIEluIGNhc2UgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgYWxsb3dlZCBsaW1pdCwgdGhlIGNvbGxlY3Rpb24gbGltaXQgd2lsbCBiZSB1c2VkLiAgSWYgYXZvaWRlZCwgdGhlIGNvbGxlY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIHBhZ2Ugc2l6ZSBpdHNlbGYuXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBQYXlvdXRzQXBpXG4gICAqL1xuICBwdWJsaWMgbGlzdFBheW91dHMoXG4gICAgc291cmNlPzogc3RyaW5nLFxuICAgIGRlc3RpbmF0aW9uPzogc3RyaW5nLFxuICAgIHR5cGU/OiBTZXQ8UGF5b3V0RGVzdGluYXRpb25UeXBlPixcbiAgICBzdGF0dXM/OiBTZXQ8UGF5b3V0U3RhdHVzPixcbiAgICBzb3VyY2VDdXJyZW5jeT86IFwiVVNEXCIgfCBcIkVVUlwiIHwgXCJCVENcIiB8IFwiRVRIXCIgfCBcIk1UQ1wiIHwgXCJGTFdcIiB8IFwiTUFOXCIsXG4gICAgZGVzdGluYXRpb25DdXJyZW5jeT86IFwiVVNEXCIgfCBcIkVVUlwiIHwgXCJCVENcIiB8IFwiRVRIXCIgfCBcIk1UQ1wiIHwgXCJGTFdcIiB8IFwiTUFOXCIsXG4gICAgY2hhaW4/OlxuICAgICAgfCBcIkFMR09cIlxuICAgICAgfCBcIkFWQVhcIlxuICAgICAgfCBcIkJUQ1wiXG4gICAgICB8IFwiRVRIXCJcbiAgICAgIHwgXCJGTE9XXCJcbiAgICAgIHwgXCJIQkFSXCJcbiAgICAgIHwgXCJNQVRJQ1wiXG4gICAgICB8IFwiU09MXCJcbiAgICAgIHwgXCJUUlhcIlxuICAgICAgfCBcIlhMTVwiLFxuICAgIGZyb20/OiBzdHJpbmcsXG4gICAgdG8/OiBzdHJpbmcsXG4gICAgcGFnZUJlZm9yZT86IHN0cmluZyxcbiAgICBwYWdlQWZ0ZXI/OiBzdHJpbmcsXG4gICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICApIHtcbiAgICByZXR1cm4gUGF5b3V0c0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5saXN0UGF5b3V0cyhcbiAgICAgICAgc291cmNlLFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBzb3VyY2VDdXJyZW5jeSxcbiAgICAgICAgZGVzdGluYXRpb25DdXJyZW5jeSxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBwYWdlQmVmb3JlLFxuICAgICAgICBwYWdlQWZ0ZXIsXG4gICAgICAgIHBhZ2VTaXplLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cbn1cbiJdfQ==